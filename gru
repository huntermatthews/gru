#!/usr/bin/env fish
## -*- mode: fish -*- ##

# This is a global variable that is used to control the debug state.
set -g _debug false

function debug_state
    # This function is used to set the debug state.
    argparse --name (status basename) --min-args 1 --max-args 1 -- $argv
    or begin
        exit 1
    end

    # single argument is our subcommand
    switch $argv[1]
        case on
            set _debug true
        case off
            set _debug false
        case status
            echo "DEBUG: debug state is $_debug"
        case '*'
            echo "ERROR: Unknown subcmd $argv[1]"
            echo "Usage: debug_state on|off|status"
    end
end

function debug
    if is_true $_debug
        echo "DEBUG: $argv" 1>&2
    end
end

function debug_var -S
    # The -S is magic that allows this debug function to peer into other functions private variables...

    # Its NOT all powerful - note that debugging "argv" from other functions WILL fail if you attempt to use it here.
    # Instead >> debug "argv == '$argv'" << is required. Sorry.
    if test $argv[1] = argv
        echo "ERROR: You are a moron. You can't debug_var argv itself..." 1>&2
        exit 11
    end
    if is_true $_debug
        echo "DEBUG: variable $argv[2] == '$$argv[2]'" 1>&2
    end
end

# PATH and other vars that are typically (longer) lists are hard to read with just debug_var
# This function will print out the variable name, and then each index of the variable on a new line.
function debug_var_list -S
    # The -S is magic that allows this debug function to peer into other functions private variables...
    if is_true $_debug
        set -l count (count $$argv[1])
        if test $count -eq 0
            echo "DEBUG: variable $argv[1] of length $count == '$$argv[1]'" 1>&2
        else
            echo "DEBUG: variable $argv[1] of length $count:" 1>&2
            for i in (seq (count $$argv[1]))
                echo "     debug: index: $i, Value: $$argv[1][$i]" 1>&2
            end
        end
    end
end
## -*- mode: fish -*- ##

# from https://fishshell.com/docs/current/cmds/fish_git_prompt.html:
# "Boolean options (those which enable or disable something) understand “1”, “yes” or “true” to
# mean true and every other value to mean false." Should I add "True" to this list?
# Recall that for SHELL/fish programming, an 'if' test is reversed from normal boolean logic.
#      Think of it like this - did X fail? if X == 'did X fail?' -- which cause the true block to be '0'
#      Yes, shell programming is weird - its not my fault.
function is_true
    set truths true yes 1
    if contains $argv $truths
        return 0
    end
    return 1
end

function is_false
    set truths true yes 1
    if contains $argv $truths
        return 1
    end
    return 0
end

function is_false_or_empty
    # This is a bit of a hack - but it works.
    # We want to check for empty or false - so we check for empty first.
    # If its empty, we return success(0). If its not empty, we check for false.
    # If its false, we return success. If its not false, we return failure.
    if test -z $argv
        return 0
    end
    if is_false $argv
        return 0
    end
    return 1
end
# From https://github.com/mattmc3/dict.fish/blob/main/functions/dict.fish
# License == MIT
#     https://github.com/mattmc3/dict.fish/blob/main/LICENSE

function __dict_usage
    echo "dict [-h|--help]"
    echo "dict keys [DICTNAME]"
    echo "dict values [DICTNAME]"
    echo "dict get [DICTNAME] [KEY]"
    echo "dict set [DICTNAME] [KEY] [VALUE]"
    echo "dict remove [DICTNAME] [KEY]"
    echo "dict contains [-k|--key] [-v|--value] [-i|--index] [DICTNAME] [STRING]"
end

function __dict_check_dictname -a dictname
    # Check to see that the DICTNAME provided is a valid variable.
    if not set -q -- $dictname
        echo >&2 "dict: Bad DICTNAME. Variable not found: '$dictname'."
        return 2
    end
end

function __dict_contains --no-scope-shadowing
    argparse --name dict --stop-nonopt --exclusive k,v k/key v/value i/index -- $argv
    or return
    set --local -- dictname $argv[1]
    __dict_check_dictname $dictname; or return $status
    set --local -- thedict $$dictname

    set --local start 1
    set --local step 1
    set --local found 0
    if set -q _flag_value
        set start 2
    end
    if set -q _flag_key; or set -q _flag_value
        set step 2
    end

    for idx in (seq $start $step (count $thedict))
        if test $thedict[$idx] = $argv[2]
            if set -q _flag_index
                if set -q _flag_value
                    echo $idx
                else
                    math $idx + 1
                end
            end
            set found 1
        end
    end
    test $found -gt 0; and return 0; or return 1
end

function dict \
    --description "Treat a paired list like a dict" \
    --no-scope-shadowing

    argparse --name dict --ignore-unknown --stop-nonopt h/help -- $argv
    if set -q _flag_help
        __dict_usage; and return 0
    else if test (count $argv) -eq 0
        __dict_usage; and return 1
    end

    set --local subcommand $argv[1]
    set argv $argv[2..]

    # The 'contains' subcommand is more involved so skip it, but for the others we can
    # do this prep logic here.
    set --local thedict
    set --local dictname
    set --local idx

    if test $subcommand != contains
        set -- dictname $argv[1]
        set -- thedict $$dictname
        __dict_check_dictname $dictname; or return $status
    end
    set --local dictsize (count $thedict)

    switch $subcommand
        case keys
            test $dictsize -gt 0; or return 0
            for idx in (seq 1 2 $dictsize)
                echo $thedict[$idx]
            end
        case values
            test $dictsize -gt 0; or return 0
            for idx in (seq 2 2 $dictsize)
                echo $thedict[$idx]
            end
        case get
            test $dictsize -gt 0; or return 1
            set --local key $argv[2]
            for idx in (seq 1 2 $dictsize)
                if test $thedict[$idx] = "$key"
                    echo $thedict[(math $idx + 1)]
                    return 0
                end
            end
            return 1
        case set
            set --local key $argv[2]
            set --local value "$argv[3..]"
            if test $dictsize -eq 0
                set $dictname $key $value
                return 0
            end

            for idx in (seq 1 2 $dictsize)
                if test $thedict[$idx] = "$key"
                    if test $idx -eq 1
                        set $dictname $key $value $thedict[3..]
                    else
                        set $dictname $thedict[1..(math $idx - 1)] $key $value $thedict[(math $idx + 2)..]
                    end
                    return 0
                end
            end
            set $dictname $key $value $thedict
        case remove
            set --local key $argv[2]
            for idx in (seq 1 2 (count $thedict))
                if test $thedict[$idx] = "$key"
                    if test $idx -eq 1
                        set $dictname $thedict[3..]
                    else
                        set $dictname $thedict[1..(math $idx - 1)] $thedict[(math $idx + 2)..]
                    end
                    return 0
                end
            end
            return 1
        case contains
            __dict_contains $argv
            return $status
        case '*'
            echo >&2 "dict: Subcommand not found '$subcommand'."
            return 2
    end
end
## -*- mode: fish -*- ##
## -*- mode: fish -*- ##

# ws_trim, to_upper, to_lower, are all in the string command - do not replicate.
## -*- mode: fish -*- ##

set -g HELP "
Usage: $(status basename) [OPTIONS] [FILE]
Options:
  -h, --help      Show this help message and exit
  -v, --version   Show version information and exit
    other docs later
"
set -g PROGRAM (status basename)
set -g VERSION "1.2"

# For all of dots, this is correct - my code, my rules.
function fish_command_not_found
    exit 12
end

function panic
    if set -q FLAG_DEBUG; and test "$FLAG_DEBUG" = true
        status stack-trace
    end

    echo "FATAL: $argv"
    exit 1
end

function main
    argparse --name $PROGRAM debug h/help version test= -- $argv
    or begin
        echo $HELP
        exit 1
    end

    if set -q _flag_help
        echo $HELP
        exit 0
    end

    if set -q _flag_version
        echo $PROGRAM v$VERSION
        exit 0
    end

    if test (uname) != Linux
        panic "Only for linux yet."
    end

    if test (uname -m) != x86_64
        panic "Only for x86_64 yet."
    end

    # todo section
    echo "todo: check minimum version requirement - v4.0"
    echo "todo: do we demand being root?"
    echo "todo: set pragma to remove ? from globbing"

    # Do stuff here
    echo "Do Stuff here"

end

# Call main
main $argv
